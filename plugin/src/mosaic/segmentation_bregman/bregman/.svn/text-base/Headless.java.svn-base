package bregman;

import ij.IJ;
import ij.ImagePlus;

import java.io.File;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Date;

public class Headless {
	public  int hcount=0;
	public  String headlesscurrent;
	PrintWriter out;
	PrintWriter out2;
	PrintWriter out3;
	String wpath;


	public Headless(String path){
		wpath=path;
		
		boolean processdirectory =(new File(wpath)).isDirectory();
		if(processdirectory){
			IJ.log("Processing directory");
			Headless_directory();
		}
		else{
			IJ.log("Processing file");
			Headless_file();
		}

	}

	public void Headless_file(){
		try{
			Analysis.p.wd= (new File(wpath)).getParent() +File.separator;
			ImagePlus img=IJ.openImage(wpath);
			Analysis.p.nchannels=img.getNChannels();

			//IJ.log(wpath);
			String savepath =  wpath.substring(0,wpath.length()-4);
			//IJ.log(savepath);

			
			if(Analysis.p.nchannels==2){
				//IJ.log("looking for files at " + wpath);
				out  = new PrintWriter(savepath+"_coloc"+ ".csv");
				out2 = new PrintWriter(savepath+"_Xdata"+ ".csv");
				out3 = new PrintWriter(savepath+"_Ydata"+ ".csv");
				//PrintWriter out = new PrintWriter(dir1.replaceAll("/", "_") + ".csv");
				//IJ.log("files open");

				out.print("Min intensity X " + Analysis.p.min_intensity +"," +
						"Min intensity Y" + Analysis.p.min_intensityY+"," +
						"Min vesicle size" + Analysis.p.minves_size+"," +
						"Max vesicle size" + Analysis.p.maxves_size+"," +
						"Overlap threshold" + Analysis.p.colocthreshold
						);

				out.println();
				out.print("File"+ "," +"Image number" + ","+ "Objects ch X" + "," + "Mean size ch X"  +"," 
						+ "Objects ch Y"+"," + "Mean size ch Y" +"," + "Colocalization X in Y"
						+"," + "Colocalization Y in X"
						+"," + "Mean Y intensity in X objects"
						+"," + "Mean X intensity in Y objects");
				out.println();




				out2.print("Image number" + "," + "Region in X"+ "," + "Overlap with Y" + "," + "Size" + "," +
						"Intensity" + "," + "MColoc size" + ","+ "MColoc Intensity" + "," + "Single Coloc" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out2.println();



				out3.print("Image number" + "," + "Region in Y"+ "," + "Overlap with X" + "," + "Size" + "," +
						"Intensity" + "," + "MColoc size" + ","+ "MColoc Intensity" + "," + "Single Coloc" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out3.println();


				out.flush();

			}

			else
			{
				out2 = new PrintWriter(savepath+"_Objectsdata"+ ".csv");


				out2.print("Image number" + "," + "Region in X"+ "," + "Size" + "," + "Perimeter" + "," + "Length" + "," +
						"Intensity" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out2.println();

				out2.flush();


			}
			//IJ.log("single file start headless");
			bcolocheadless(img);
			IJ.log("");
			IJ.log("Done");
			
		}catch (Exception e){//Catch exception if any
			System.err.println("Error headless file processing: " + e.getMessage());
		}

	}

	public void Headless_directory(){
		//IJ.log("starting dir");
		try{
			wpath=wpath + File.separator;
			Analysis.p.wd= wpath;
			Analysis.doingbatch=true;

			Analysis.p.livedisplay=false;

			IJ.log(Analysis.p.wd);
			long Time = new Date().getTime(); //start time

			String [] list = new File(wpath).list();
			if (list==null) {IJ.log("No files in folder"); return;}
			Arrays.sort(list);

			IJ.log("la");
			int ii=0;
			boolean imgfound=false;
			while (ii<list.length && !imgfound) {
				IJ.log("read"+list[ii]);
				boolean isDir = (new File(wpath+list[ii])).isDirectory();
				if (	!isDir &&
						!list[ii].startsWith(".")&&
						!list[ii].startsWith("Coloc") &&
						!list[ii].startsWith("X_Vesicles")&&
						!list[ii].startsWith("Y_Vesicles")&&
						!list[ii].endsWith("_seg_c0.tif")&&
						!list[ii].endsWith("_seg_c1.tif")&&
						!list[ii].endsWith("_mask_c0.tif")&&
						!list[ii].endsWith("_mask_c1.tif")&&
						!list[ii].endsWith("_coloc.tif")&&
						!list[ii].endsWith(".zip")&&
						list[ii].endsWith(".tif")
						){

					ImagePlus img=IJ.openImage(wpath+list[ii]);
					Analysis.p.nchannels=img.getNChannels();
					imgfound=true;

				}
				ii++;
			}


			IJ.log("nchannels" + Analysis.p.nchannels);

			if(Analysis.p.nchannels==2){
				IJ.log("looking for files at " + wpath);
				out  = new PrintWriter(wpath +"Colocalization"+ Time   + ".csv");
				out2 = new PrintWriter(wpath +"X_Vesicles_data"+ Time + ".csv");
				out3 = new PrintWriter(wpath +"Y_Vesicles_data"+ Time + ".csv");
				//PrintWriter out = new PrintWriter(dir1.replaceAll("/", "_") + ".csv");
				//IJ.log("files open");

				out.print("Min intensity X " + Analysis.p.min_intensity +"," +
						"Min intensity Y" + Analysis.p.min_intensityY+"," +
						"Min vesicle size" + Analysis.p.minves_size+"," +
						"Max vesicle size" + Analysis.p.maxves_size+"," +
						"Overlap threshold" + Analysis.p.colocthreshold
						);

				out.println();
				out.print("File"+ "," +"Image number" + ","+ "Objects ch X" + "," + "Mean size ch X"  +"," 
						+ "Objects ch Y"+"," + "Mean size ch Y" +"," + "Colocalization X in Y"
						+"," + "Colocalization Y in X"
						+"," + "Mean Y intensity in X objects"
						+"," + "Mean X intensity in Y objects");
				out.println();




				out2.print("Image number" + "," + "Region in X"+ "," + "Overlap with Y" + "," + "Size" + "," +
						"Intensity" + "," + "MColoc size" + ","+ "MColoc Intensity" + "," + "Single Coloc" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out2.println();



				out3.print("Image number" + "," + "Region in Y"+ "," + "Overlap with X" + "," + "Size" + "," +
						"Intensity" + "," + "MColoc size" + ","+ "MColoc Intensity" + "," + "Single Coloc" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out3.println();


				out.flush();

			}

			else
			{

				out2 = new PrintWriter(wpath +"Objects_data"+ Time + ".csv");


				out2.print("Image number" + "," + "Region in X"+ "," + "Size" + "," + "Perimeter" + "," + "Length" + "," +
						"Intensity" + ","  + "Coord X"+ "," + "Coord Y"+ "," + "Coord Z");
				out2.println();

				out2.flush();


			}

			for (int i=0; i<list.length; i++) {
				IJ.log("read"+list[i]);
				boolean isDir = (new File(wpath+list[i])).isDirectory();
				if (	!isDir &&
						!list[i].startsWith(".") &&
						!list[i].startsWith("Coloc") &&
						!list[i].startsWith("X_Vesicles")&&
						!list[i].startsWith("Objects_data")&&
						!list[i].startsWith("Y_Vesicles")&&
						!list[i].endsWith("_seg_c0.tif")&&
						!list[i].endsWith("_seg_c1.tif")&&
						!list[i].endsWith("_mask_c0.tif")&&
						!list[i].endsWith("_mask_c1.tif")&&
						!list[i].endsWith("_coloc.tif")&&
						list[i].endsWith(".tif")&&
						!list[i].endsWith(".zip")
						){
					IJ.log("Analyzing " + list[i]+ "... ");
					ImagePlus img=IJ.openImage(wpath+list[i]);
					IJ.log("opened");
					bcolocheadless(img);
					//IJ.log("done");
				}
			}
			IJ.log("");
			IJ.log("Done");
			finish();
		}catch (Exception e){//Catch exception if any
			System.err.println("Error headless: " + e.getMessage());
		}
		Analysis.doingbatch=false;
	}

	public void bcolocheadless(ImagePlus img2){
		Analysis.doingbatch=true;


		Analysis.p.livedisplay=false;

		Analysis.p.nchannels=img2.getNChannels();

		if(Analysis.p.nchannels==2){
			Analysis.load2channels(img2);
		}

		if(Analysis.p.nchannels==1){
			Analysis.load1channel(img2);
		}

		//Analysis.p.dispvoronoi=true;
		//Analysis.p.livedisplay=true;

		Analysis.p.ni=Analysis.imgA.getWidth();
		Analysis.p.nj=Analysis.imgA.getHeight();
		Analysis.p.nz=Analysis.imgA.getNSlices();

		
		Analysis.segmentA();			 

		try{
			Analysis.DoneSignala.await();
		}catch (InterruptedException ex) {}


		//IJ.log("imgb :" +list[i+1]);

		if(Analysis.p.nchannels==2){
			Analysis.segmentb();			 

			try {
				Analysis.DoneSignalb.await();
			}catch (InterruptedException ex) {}
		}


		//TODO : why is it needed to reassign p.ni ...??
		Analysis.p.ni=Analysis.imgA.getWidth();
		Analysis.p.nj=Analysis.imgA.getHeight();
		Analysis.p.nz=Analysis.imgA.getNSlices();



		if(Analysis.p.nchannels==2){


			Analysis.computeOverallMask();
			Analysis.regionslistA=Analysis.removeExternalObjects(Analysis.regionslistA);
			Analysis.regionslistB=Analysis.removeExternalObjects(Analysis.regionslistB);

			Analysis.setRegionsLabels(Analysis.regionslistA, Analysis.regionsA);
			Analysis.setRegionsLabels(Analysis.regionslistB, Analysis.regionsB);
			Analysis.setIntensitiesandCenters(Analysis.regionslistA,Analysis.maskA);
			Analysis.setIntensitiesandCenters(Analysis.regionslistB,Analysis.maskB);

			Analysis.na=Analysis.regionslistA.size();
			Analysis.nb=Analysis.regionslistB.size();

			MasksDisplay md= new MasksDisplay(Analysis.p.ni,Analysis.p.nj,Analysis.p.nz,Analysis.p.nlevels,Analysis.p.cl,Analysis.p);
			md.displaycoloc(Analysis.regionslistA,Analysis.regionslistB);

			double colocAB=Tools.round(Analysis.colocsegAB(out2, hcount),4);
			double colocBA=Tools.round(Analysis.colocsegBA(out3, hcount),4);
			double colocA=Tools.round(Analysis.colocsegA(null),4);
			double colocB=Tools.round(Analysis.colocsegB(null),4);
			out.print(img2.getTitle() + "," + hcount +","+ Analysis.na + "," +
					Tools.round(Analysis.meana , 4)  +"," + Analysis.nb +"," + 
					Tools.round(Analysis.meanb , 4) +"," +
					colocAB +"," + 
					colocBA + ","+
					colocA+ ","+
					colocB);
			out.println();
			out.flush();
			out2.flush();
			out3.flush();


			Analysis.doingbatch=false;
			hcount++;

		}


		if(Analysis.p.nchannels==1){


			//	Analysis.setRegionsLabels(Analysis.regionslistA, Analysis.regionsA);

			Analysis.na=Analysis.regionslistA.size();




			Analysis.setIntensitiesandCenters(Analysis.regionslistA,Analysis.maskA);		
			Analysis.setPerimeter(Analysis.regionslistA,Analysis.regionsA);	
			Analysis.setlength(Analysis.regionslistA,Analysis.regionsA);	
			Analysis.printobjects(out2, hcount);

			out2.flush();



			Analysis.doingbatch=false;
			hcount++;

		}


	}

	public  void finish(){
		if(Analysis.p.nchannels==2){
			out.close();
			out2.close();
			out3.close();
		}
		else
			out2.close();
	}



}
