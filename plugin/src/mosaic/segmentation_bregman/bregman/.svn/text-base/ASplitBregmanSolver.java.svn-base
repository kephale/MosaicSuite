package bregman;

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.plugin.ZProjector;
import ij.process.ByteProcessor;
import ij.process.FloatProcessor;
import edu.emory.mathcs.jtransforms.dct.DoubleDCT_2D;

import java.util.ArrayList;
import java.util.Date;
import java.util.concurrent.CountDownLatch;

import bregman.FindConnectedRegions.Region;

public class ASplitBregmanSolver {
	public DoubleDCT_2D dct2d;
	double totaltime=0;
	boolean StopFlag;

	public ArrayList<Region> regionslistr;
	public MasksDisplay md;
	public double [] [] [] image;
	public double weight;
	public double norm;
	public double [] [] [] [] speedData; //used only
	public double energt;
	//public double [] [] [] [] mask;

	public double [] [] eigenLaplacian;

	int stepk;

	public int channel;
	public double [] [] [] [] w1k;
	public double [] [] [] [] w3k;

	public double [] [] [] [] w2xk;
	public double [] [] [] [] w2yk;

	public double [] [] [] [] w3kbest;
	public int iw3kbest;
	public double [] [] [] [] b2xk;
	public double [] [] [] [] b2yk;

	public double [] [] []  RSSweights;

	public double [] [] [] [] b1k;
	public double [] [] [] [] b3k;

	public int  [] [] [] maxmask;
	public int  [] [] [] maxmask0;


	//public double [] [] [] [] w3kp; // used for norm calculation : not used now

	//public double [] [] [] [] divwb;
	//public double [] [] [] [] RHS;

	public double [] [] [] [] temp1;
	public double [] [] [] [] temp2;
	public double [] [] [] [] temp3;
	public double [] [] [] [] temp4;

	public float [] [] [] [] Ri;
	public float [] [] [] [] Ro;

	public double [] energytab;
	public double [] normtab;
	int ni, nj, nz;
	int nl;
	public double energy, lastenergy;
	public double bestNrj;
	public Parameters p;
	public RegionStatisticsSolver RSS;


	public ASplitBregmanSolver(Parameters params,
			double [] [] [] image, double [] [] [] [] speedData, double [] [] [] [] mask,
			MasksDisplay md, int channel){
		//initialization
		IJ.log("nlevels asplit" + params.nlevels);
		this.channel=channel;
		bestNrj=Double.MAX_VALUE;
		this.p= params;
		this.ni=params.ni ;
		this.nj=params.nj ;
		this.nz=params.nz ;
		IJ.log("nlevels asplit" + p.nlevels);
		this.nl=p.nlevels;
		IJ.log("nlevels asplit" + p.nlevels);
		this.energytab= new double [nl];
		this.normtab= new double [nl];

		this.StopFlag=false;
		this.md= md;
		IJ.log("nlevels asplit" + p.nlevels);
		dct2d= new DoubleDCT_2D(ni,nj);
		IJ.log("nlevels asplit" + p.nlevels);
		//speedData used as temp tab

		//if(nz>1)dct3d= new DoubleDCT_3D(nz,ni,nj);
		this.image=image;
		this.speedData=speedData;//used only for NRegions and two regions without PSF
		//this.mask=mask;


		this.eigenLaplacian= new double [ni] [nj];

		//allocate
		this.w1k= new double [nl] [nz] [ni] [nj];
		this.w3k= new double [nl] [nz] [ni] [nj];
		this.w3kbest= new double [nl] [nz] [ni] [nj];
		//this.w3kp= new double [nl] [nz] [ni] [nj];


		this.b2xk= new double [nl] [nz] [ni] [nj];
		this.b2yk= new double [nl] [nz] [ni] [nj];

		this.b1k= new double [nl] [nz] [ni] [nj];
		this.b3k= new double [nl] [nz] [ni] [nj];

		this.w2xk= new double [nl] [nz] [ni] [nj];
		this.w2yk= new double [nl] [1] [ni] [nj];//save memory w2yk not used in 3d case

		this.Ri= new float [nl] [nz] [ni] [nj];
		this.Ro= new float [nl] [nz] [ni] [nj];

		this.maxmask= new int  [nz] [ni] [nj];
		this.maxmask0= new int [nz] [ni] [nj];

		int nzmin;
		if(nz>1){nzmin=Math.max(7, nz);}
		else nzmin=nz;
		this.temp1= new double [nl] [nzmin] [ni] [nj];
		this.temp2= new double [nl] [nzmin] [ni] [nj];
		this.temp3= new double [nl] [nzmin] [ni] [nj];
		this.temp4= new double [nl] [nzmin] [ni] [nj];// hack to make it work : used for eigenPSF 7*7*7

		//temp4, temp5, speedData
		this.RSS= new RegionStatisticsSolver(temp1[0],temp2[0], temp3[0],image,10,p);

		//precompute eigenlaplacian
		for (int i=0; i<ni; i++){  
			for (int j=0;j< nj; j++){  
				this.eigenLaplacian[i][j]=2+(2-2*Math.cos((j)*Math.PI/(nj))+ (2-2*Math.cos((i)*Math.PI/(ni))));			
			}	
		}

		for(int i =0; i< nl;i++){
			//temp1=w2xk temp2=w2yk
			Tools.fgradx2D(temp1[i], mask[i]);
			Tools.fgrady2D(temp2[i], mask[i]);

			Tools.copytab(w1k[i], mask[i]);
			Tools.copytab(w3k[i], mask[i]);
		}

		if(p.RSSinit){
			RSS.eval(w3k[0]);
			//Analysis.p.cl[0]=RSS.betaMLEout;
			//Analysis.p.cl[1]=RSS.betaMLEin;

			p.cl[0]=RSS.betaMLEout;
			p.cl[1]=RSS.betaMLEin;
			
			IJ.log(String.format("Photometry init:%n background %7.2e %n foreground %7.2e", RSS.betaMLEout,RSS.betaMLEin));	
		}
		
		if(p.remask){
			Tools.createmask(mask,image,p.cl);
			md.display2regionsnewd(mask[0][0], "remask init", 0);;
			
		}


		for(int l =0; l< nl;l++){
			for (int z=0; z<nz; z++){
				for (int i=0; i<ni; i++) {  
					for (int j=0; j<nj; j++) {  
//						Ro[l][z][i][j]=(float) (Analysis.p.cl[0]);
//						Ri[l][z][i][j]=(float) (Analysis.p.cl[1]);
						Ro[l][z][i][j]=(float) (p.cl[0]);
						Ri[l][z][i][j]=(float) (p.cl[1]);
					}	
				}
			}
		}

		//RSS.eval(w3k[0]);
		//IJ.log(String.format("Photometry init :%n backgroung %7.2e %n foreground %7.2e", RSS.betaMLEout,RSS.betaMLEin));	

	}


	//first run
	public void first_run() throws InterruptedException {

		//initialize variables
		for(int l =0; l< nl;l++){
			for (int z=0; z<nz; z++){
				for (int i=0; i<ni; i++) {  
					for (int j=0; j<nj; j++) {  
						b2xk[l][z][i][j]=0;b2yk[l][z][i][j]=0;
						b1k[l][z][i][j]=0;b3k[l][z][i][j]=0;
					}	
				}
			}
		}


		stepk=0;
		totaltime=0;
		int modulo=10;

		IJ.showStatus("Computing segmentation");
		IJ.showProgress(0.0);


		while(stepk<p.max_nsb  && !StopFlag){
			//Bregman step
			step();

			//energy=500-stepk;
			//stop criterion
			if(energy < bestNrj) {
				Tools.copytab(w3kbest[0], w3k[0]);
				iw3kbest=stepk;
				bestNrj=energy;}
			if(stepk % p.energyEvaluationModulo ==0 || stepk==p.max_nsb -1){	
				if(Math.abs((energy-lastenergy)/lastenergy) < p.tol){ StopFlag=true;IJ.log("energy stop");}
			}
			lastenergy=energy;
			//energy output
			//if(p.livedisplay){

			if(stepk % modulo ==0)
				IJ.log(String.format("Energy at step %d : %7.6e", stepk, energy));	
				//IJ.log("Energy at step :" + stepk+ " : " +Tools.round(energy,3));

			//IJ.log("Best energy step: " + stepk + " : " + Tools.round(bestNrj , 3));+ " norm between masks " + Tools.round(norm, 2));
			//}
			if((stepk+1) % p.RSSmodulo ==0 && stepk!=0){
				RSS.eval(w3k[0]);
				//Analysis.p.cl[0]=RSS.betaMLEout;
				//Analysis.p.cl[1]=RSS.betaMLEin;
				p.cl[0]=RSS.betaMLEout;
				p.cl[1]=RSS.betaMLEin;
				this.init();
				IJ.log(String.format("Photometry :%n backgroung %10.8e %n foreground %10.8e", RSS.betaMLEout,RSS.betaMLEin));	
			}
			if(p.RegionsIntensitymodulo ==stepk && stepk!=0){
				IJ.log("best energy at"+iw3kbest);
				this.regions_intensity(w3kbest[0]);
				this.init();

			}

			stepk++;
			if(stepk % modulo ==0)IJ.showStatus("Computing segmentation  " + Tools.round((((double) 100* stepk)/(p.max_nsb-1)),2) + "%");

			IJ.showProgress(((double) stepk)/(p.max_nsb-1));
		}


		if (p.findregionthresh ){//&& p.nz==1){
			this.regions_intensity_findthresh(w3kbest[0]);
		}
		IJ.showStatus("Segmentation Done");
		//display combination of masks
		//if(p.nlevels==1 && p.nz==1) md.display2regionsnew(w3kbest[0][0], "Best Mask", channel);
		if(p.livedisplay){if(p.nlevels<=2 && p.nz==1)  md.display2regions(w3kbest[0][0], "Mask", channel);}
		if(p.livedisplay && p.nz>1 &&p.nlevels<=2) md.display2regions3D(w3kbest[0], "Mask", channel);

		//if(p.nz>1) md.display2regions3D(w3k[0], "Mask");
		////if(p.nz>1) md.display2regions3Dscaled(w3k[0], "Mask scaled");
		//if(p.nz>1) md.display2regions3Dscaledcolor(w3k[0], "Mask scaled");
		if(p.livedisplay){if(p.nlevels>2)md.display(maxmask, "Masks");}
		IJ.log("Best energy : " + Tools.round(bestNrj , 3)+ ", found at step " + iw3kbest);
		IJ.log("Total time: " + totaltime/1000 + "s");
	}


	public void run() throws InterruptedException{
		stepk=0;
		while(stepk< p.max_nsb){
			step();
			if(energy < bestNrj) bestNrj=energy;
			stepk++;
		}
	}



	protected void step() throws InterruptedException {
		long lStartTime = new Date().getTime(); //start time
		//energy=0;

		//-- uk sub-problem
		//IJ.log("creates latch ");
		CountDownLatch RegionsTasksDoneSignal = new CountDownLatch(nl);//subprob 1 and 3
		CountDownLatch UkDoneSignal = new CountDownLatch(nl);
		CountDownLatch W3kDoneSignal = new CountDownLatch(1);

		for(int l=0; l< nl;l++){
			new Thread(new SingleRegionTask(RegionsTasksDoneSignal,UkDoneSignal,W3kDoneSignal, l,this)).start();
		}


		//%-- w3k subproblem		
		UkDoneSignal.await(); 

		ProjectSimplexSpeed.project(w3k, temp4, ni,nj,nl);

		W3kDoneSignal.countDown();
		RegionsTasksDoneSignal.await(); 

		Tools.max_mask(maxmask, w3k);

		// number of != pixels in max mask (stop criterion ?)
		//int diff;
		//diff=Tools.computediff(maxmask, maxmask0);
		//IJ.log("diff in pixels : " +  diff);
		//Tools.copytab(maxmask0, maxmask);

		//doneSignal2.await();
		norm=0;
		energy=0;
		for(int l=0; l< nl;l++){
			energy+=energytab[l];
			norm=Math.max(norm, normtab[l]);
		}

		if(p.livedisplay) md.display(maxmask, "Masks");

		//if(p.livedisplay) md.display2regions(w3k[1][0], "Mask lev 1",0);




		long lEndTime = new Date().getTime(); //end time

		long difference = lEndTime - lStartTime; //check different
		totaltime +=difference;
		//IJ.log("Elapsed milliseconds: " + difference);


	}

	public void init(){
	}

	public void compute_eigenPSF(){
	}

	public void regions_intensity(double [][][] mask){
		int [] [] [] regions;
		//  ArrayList<Region> regionslistr;
		double thresh=0.4;

		ImagePlus mask_im= new ImagePlus();
		ImageStack mask_ims= new ImageStack(p.ni,p.nj);
		for (int z=0; z<nz; z++){
			byte[] mask_bytes = new byte[p.ni*p.nj];
			for (int i=0; i<ni; i++) {  
				for (int j=0; j<nj; j++) {  
					if(mask[z][i][j]> thresh)
						mask_bytes[j * p.ni + i]= 0;
					else
						mask_bytes[j * p.ni + i]=(byte) 255;
				}
			}

			ByteProcessor bp = new ByteProcessor(p.ni, p.nj);
			bp.setPixels(mask_bytes);
			mask_ims.addSlice("", bp);

		}
		mask_im.setStack("Regions",mask_ims);

		IJ.run(mask_im,"Voronoi","");
		IJ.run(mask_im,"Invert","");
		IJ.run(mask_im,"3-3-2 RGB", "");
		mask_im.show("Voronoi");



		double thr=254;
		FindConnectedRegions fcr= new FindConnectedRegions(mask_im);

		for (int z=0; z<nz; z++){
			for (int i=0; i<ni; i++) {  
				for (int j=0; j<nj; j++) {  
					Ri[0][z][i][j]=(float)thr;
				}
			}
		}

		fcr.run(thr,0,512*512,2,0,Ri[0],false,false);

		//		IJ.selectWindow("Test Voronoi");
		//		IJ.setThreshold(0, 254);
		//		IJ.run("Convert to Mask");
		//		ImagePlus imp1 = IJ.getImage();
		//		IJ.selectWindow("Mask X");
		//		IJ.run("8-bit");
		//		ImagePlus imp2 = IJ.getImage();
		//		ImageCalculator ic = new ImageCalculator();
		//		ImagePlus imp3 = ic.run("Add", imp1, imp2);
		//		IJ.run(imp3, "Invert LUT", "");
		//		//imp3.show();
		//		IJ.selectWindow("Mask X");

		regions=fcr.tempres;
		this.regionslistr=fcr.results;
		int na=regionslistr.size();

		double total=Analysis.totalsize(regionslistr);
		IJ.log(na + " Voronoi1 cells found, total area : " + Tools.round(total,2)+ " pixels.");

	////////corect  Ri and Ro not double	RSS.eval(w3k[0], Ri[0], Ro[0], regionslistr);
		//	ImagePlus img=md.display2regionsnew(Ri[0][0], "Ri", 1);
		//	ImagePlus img2=md.display2regionsnew(Ro[0][0], "Ro", 1);
	
		RSS.cluster_region(Ri[0], Ro[0], regionslistr);
		ImagePlus img3=md.display2regionsnew(Ri[0][0], "Ri cluster", 1);
		ImagePlus img4=md.display2regionsnew(Ro[0][0], "Ro cluster", 1);	
	}	

	public void regions_intensity_findthresh(double [][][] mask){
		int [] [] [] regions;
		ArrayList<Region> regionslist;
		double thresh=p.regionthresh;//0.19

		ImagePlus mask_im= new ImagePlus();
		ImageStack mask_ims= new ImageStack(p.ni,p.nj);


		//construct mask as an imageplus
		for (int z=0; z<nz; z++){
			float[] mask_float = new float[p.ni*p.nj];
			for (int i=0; i<ni; i++) {  
				for (int j=0; j<nj; j++) {  
					mask_float[j * p.ni + i]= (float) mask[z][i][j];
				}
			}
			FloatProcessor fp = new FloatProcessor(p.ni, p.nj);
			fp.setPixels(mask_float);
			mask_ims.addSlice("", fp);
		}
		mask_im.setStack("test",mask_ims);
		//mask_im.show("test");

		//project mask on single slice (maximum values)
		ZProjector proj = new ZProjector(mask_im);
		proj.setImage(mask_im);
		proj.setStartSlice(1);proj.setStopSlice(nz);
		proj.setMethod(ZProjector.MAX_METHOD);
		proj.doProjection();
		mask_im=proj.getProjection();

		//mask_im.show();



		//threshold mask
		byte[] mask_bytes = new byte[p.ni*p.nj];
		for (int i=0; i<ni; i++) {
			for (int j=0; j<nj; j++) {  
				if(mask_im.getProcessor().getPixelValue(i,j)> thresh)
					mask_bytes[j * p.ni + i]= 0;
				else
					mask_bytes[j * p.ni + i]=(byte) 255;
			}
		}
		ByteProcessor bp = new ByteProcessor(p.ni, p.nj);
		bp.setPixels(mask_bytes);
		mask_im.setProcessor("Voronoi",bp);
		//		mask_im.show();


		//do voronoi in 2D on Z projection
		IJ.run(mask_im,"Voronoi","");
		IJ.run(mask_im,"Invert","");


		//expand Voronoi in 3D
		ImageStack mask_ims3= new ImageStack(p.ni,p.nj);
		for (int z=0; z<nz; z++){
			byte[] mask_bytes3 = new byte[p.ni*p.nj];
			for (int i=0; i<ni; i++) {
				for (int j=0; j<nj; j++) {  
					mask_bytes3[j * p.ni + i]= (byte) mask_im.getProcessor().getPixel(i,j);
				}
			}
			ByteProcessor bp3 = new ByteProcessor(p.ni, p.nj);
			bp3.setPixels(mask_bytes3);
			mask_ims3.addSlice("", bp3);
		}
		mask_im.setStack("Voronoi",mask_ims3);



		double thr=254;
		FindConnectedRegions fcr= new FindConnectedRegions(mask_im);

		for (int z=0; z<nz; z++){
			for (int i=0; i<ni; i++) {  
				for (int j=0; j<nj; j++) {  
					Ri[0][z][i][j]= (float)thr;
				}
			}
		}

		fcr.run(thr,1,p.ni*p.nj*p.nz,5,0,Ri[0],false,false);//min size was 5

		if(p.dispvoronoi){
			if(nz==1) md.display2regions(w3kbest[0][0], "Mask", channel);
			else md.display2regions3D(w3kbest[0], "Mask", channel);

			IJ.setThreshold(mask_im,0,254);
			IJ.run(mask_im,"Convert to Mask","stack");

			if(channel==0)
				IJ.selectWindow("Mask X");
			else
				IJ.selectWindow("Mask Y");
			IJ.run("8-bit","stack");
			ImagePlus imp2 = IJ.getImage();

			//add images
			ImageStack mask_ims2= new ImageStack(p.ni,p.nj);
			for (int z=0; z<nz; z++){
				//imp1.setSlice(z+1);
				imp2.setSlice(z+1);
				byte[] mask_byte2 = new byte[p.ni*p.nj];
				for (int i=0; i<ni; i++) {  
					for (int j=0; j<nj; j++) {  
						mask_byte2[j * p.ni + i]= (byte)
								Math.min((mask_im.getProcessor().getPixel(i,j) +
										imp2.getProcessor().getPixel(i,j)),255);
					}
				}
				ByteProcessor bp2 = new ByteProcessor(p.ni, p.nj);
				bp2.setPixels(mask_byte2);
				mask_ims2.addSlice("", bp2);
			}
			//replace imageplus with additon of both
			
			if(channel==0){
			mask_im.setStack("Voronoi X",mask_ims2);

			//IJ.run(imp3, "Invert LUT","stack");
			mask_im.show("Voronoi X");
			IJ.selectWindow("Mask X");}
		
			else{
				mask_im.setStack("Voronoi Y",mask_ims2);

				//IJ.run(imp3, "Invert LUT","stack");
				mask_im.show("Voronoi Y");
				IJ.selectWindow("Mask Y");
			}
			
			
		}


		regions=fcr.tempres;
		regionslist=fcr.results;
		int na=regionslist.size();

		double total=Analysis.totalsize(regionslist);
		if(p.dispvoronoi)IJ.log(na + " Voronoi cells found, total area : " + Tools.round(total,2)+ " pixels.");



		for (int z=0; z<nz; z++){
			for (int i=0; i<ni; i++) {  
				for (int j=0; j<nj; j++) {  
					Ri[0][z][i][j]=255;
				}
			}
		}


		RegionStatisticsSolver RSS2= new RegionStatisticsSolver(temp1[0],temp2[0], temp3[0], w3kbest[0],10, p);
		//RSS.eval(w3k[0], Ri[0], Ro[0], regionslist);
		//ImagePlus img=md.display2regionsnew(Ri[0][0], "Ri", 1);
		//ImagePlus img2=md.display2regionsnew(Ro[0][0], "Ro", 1);

		long lStartTime = new Date().getTime(); //start time
		RSS2.cluster_region(Ri[0], Ro[0], regionslist);
		long lEndTime = new Date().getTime(); //end time

		long difference = lEndTime - lStartTime; //check different
		totaltime +=difference;
		//IJ.log("Elapsed milliseconds RSS2: " + difference);
		if(p.dispvoronoi){
			if(p.nz==1)
			{md.display2regionsnew(Ri[0][0], "Regions thresholds", channel);}
			else
			{md.display2regions3Dnew(Ri[0], "Regions thresholds", channel);}	}
		//ImagePlus img4=md.display2regionsnew(Ro[0][0], "Ro cluster", 1);	
	}	

}
